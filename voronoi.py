#!/usr/bin/env python

import numpy as np
import matplotlib.pyplot as plt
from scipy.spatial import Voronoi, voronoi_plot_2d
from math import sqrt

# Quadrature point data generated by calling
# ./drivers/tri_rule -w -i inputs/some_file.in
# data = np.genfromtxt('quad_2d_p10_Ro3_24QP_equilateral.csv', delimiter=',')
data = np.genfromtxt('quad_2d_p10_Ro3_24QP_second_equilateral.csv', delimiter=',')
# data = np.genfromtxt('quad_2d_p10_Ro3_25QP_equilateral.csv', delimiter=',')
# data = np.genfromtxt('quad_2d_p10_Ro3_25QP_second_equilateral.csv', delimiter=',')

# Extract first two columns of data (assuming there is a third column of weights
points = data[:, [0, 1]]
wts = data[:, 2]

# Generate the Voroni diagram
vor = Voronoi(points)

# These are not the original points, they are the vertices of the
# Voronoi diagram, so there can be more of these than input points.
# print(vor.vertices)

# Debugging: print internals of the vor object.
# print(vor.ridge_vertices)

# A region with a -1 presumably has a point at infinity?
# print(vor.regions)

# Plot with fancy options
# fig = voronoi_plot_2d(vor, show_vertices=False, line_colors='orange',
#                       line_width=2, line_alpha=0.6, point_size=2)

# The tutorial gives a step by step example of making the plot.

# First plot points and Voronoi vertices. If we don't limit the size
# of the plot, there will be very far away points? Plotting the Voronoi
# vertices is not necessary for making the plot.
plt.plot(points[:, 0], points[:, 1], 'ko')
# plt.plot(vor.vertices[:, 0], vor.vertices[:, 1], '*')

# The top of the triangle is at y = sqrt(3)/2 ~ 0.8660254037844386.
# If we want the axes to be square, we need to use the same limits for
# both x and y. I found that does not really look as good, however.
border=0.05
# shift=0.5 * (1 - sqrt(3.)/2)
plt.xlim(0-border, 1+border)
plt.ylim(0-border, sqrt(3.)/2+border)

# Plot all finite length edges. Note that even the finite length
# edges may extend beyond the triangle boundaries...
for simplex in vor.ridge_vertices:
    simplex = np.asarray(simplex)
    if np.all(simplex >= 0):
        plt.plot(vor.vertices[simplex, 0], vor.vertices[simplex, 1], '-',
                 color='orange', linewidth=2, alpha=0.6)

# Now plot infinite edges
center = points.mean(axis=0)
for pointidx, simplex in zip(vor.ridge_points, vor.ridge_vertices):
    simplex = np.asarray(simplex)
    if np.any(simplex < 0):
        i = simplex[simplex >= 0][0] # finite end Voronoi vertex
        t = points[pointidx[1]] - points[pointidx[0]]  # tangent
        t = t / np.linalg.norm(t)
        n = np.array([-t[1], t[0]]) # normal
        midpoint = points[pointidx].mean(axis=0)
        far_point = vor.vertices[i] + np.sign(np.dot(midpoint - center, n)) * n * 100
        plt.plot([vor.vertices[i,0], far_point[0]],
                 [vor.vertices[i,1], far_point[1]], 'k--')


# Plot lines for the edges of the equilateral triangle
ax = plt.gca()
ax.plot([0, 1, 0.5, 0], [0, 0, sqrt(3.)/2., 0], color='k', linestyle='-', linewidth=2)

# Make x and y lengths the same. We can't do this when there are
# Voronoi points far away.
# ax.axis('equal')

# For now this is hard-coded to the test case we have, but we should
# generalize it.  This is a "1116" rule, so there is one centroid
# orbit, one vertex orbit, one edge orbit, and 6 general orbits.
region_colors = ['b', # centroid
                 'g', 'g', 'g', # vertex orbit
                 'r', 'r', 'r', # edge orbit
                 'aliceblue', 'aliceblue', 'aliceblue', # general
                 'darkkhaki', 'darkkhaki', 'darkkhaki',
                 'darkolivegreen', 'darkolivegreen', 'darkolivegreen',
                 'goldenrod', 'goldenrod', 'goldenrod',
                 'hotpink', 'hotpink', 'hotpink',
                 'mediumaquamarine', 'mediumaquamarine', 'mediumaquamarine',
                 'lightcoral' # there seems to be one extra region
]

# Here's code to fill in the non-infinite regions! If you don't specify a
# color to the 'fill' command, it chooses a random sequence of colors.
# The regions do not seem to be numbered in the same order as the points!
regctr = 0
for region in vor.regions:
    if not -1 in region:
        polygon = [vor.vertices[i] for i in region]
        plt.fill(*zip(*polygon)) #, color=region_colors[regctr])
    regctr = regctr + 1

# This prints 26, but I was expecting 25?
# print(len(vor.regions))

plt.savefig('voronoi.pdf')
